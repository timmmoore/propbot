{
Neural Network
  port of
        http://robotics.hobbizine.com/arduinoann.html

  provides training capability for nn_drive
  but recommend use
          https://github.com/timmoore/propbot/trainer
}

CON
PatternCount    = 6
InputNodes      = 5
HiddenNodes     = 6
OutputNodes     = 2

OBJ
  utilities   : "utilities"

DAT
fLearningRate            long 0.3
fMomentum                long 0.9
fInitialWeightMax        long 0.5
fSuccess                 long 0.0001

fInput {[PatternCount][InputNodes]}
  long 0.0, 0.0, 0.0, 0.0, 0.0
  long 1.0, 1.0, 1.0, 1.0, 1.0
  long 0.0, 0.0, 1.0, 0.0, 0.0
  long 0.0, 1.0, 1.0, 1.0, 0.0
  long 0.5, 0.5, 0.5, 0.5, 0.5
  long 0.0, 0.0, 0.5, 0.0, 0.0

fTarget {[PatternCount][OutputNodes]}
  long 1.0, 1.0
  long 0.0, 0.0
  long 0.6, 0.7
  long 0.8, 0.2
  long 0.6, 0.6
  long 0.5, 0.6

VAR
  long fError                                                                   ' MSE

  long start
  'long i, j                                                                     ' loop indexes
  long fAccum                                                                   ' general sum
  long p, q                                                                     ' training data indexes
  long TrainingCycle                                                            ' number of times round the training cycle

  long RandomizedIndex[PatternCount]                                            ' random order of training data

  long fHiddenDelta[HiddenNodes]                                                ' gradient for hidden weights

  long fOutputDelta[OutputNodes]                                                ' gradient for output weights

  long fHiddenWeights[(InputNodes + 1)*HiddenNodes]                             ' current hidden weights
  long fChangeHiddenWeights[(InputNodes + 1)*HiddenNodes]                       ' change to hidden weights, calculated using gradient

  long fOutputWeights[(HiddenNodes + 1)*OutputNodes]                            ' current output weights
  long fChangeOutputWeights[(HiddenNodes + 1)*OutputNodes]                      ' change to output weights, calculated using gradient

  long fOutput[OutputNodes]                                                     ' current output node values
  long fHidden[HiddenNodes]                                                     ' current hidden node values

pub null()

pri rand(r) : result
  case r
    16:                                                                         ' optimize for a couple of cases
      result := getrnd() & $0f
    128:
      result := getrnd() & $7f
    other:                                                                      ' and handle the rest
      result := getrnd() +// r

pub train_nn() | tindex, t1index, diff, i, j
' trains the network
  debug("Start training ", sdec(HiddenNodes), " ", sdec(InputNodes))

  debug(`SCOPE_XY MyXY SIZE 160 COLOR black black RANGE 80_000 SAMPLES 0 'MSE') ' plot MSE for each training cycle

  repeat p from 0 to PatternCount-1                                             ' training data index
    RandomizedIndex[p] := p

  repeat i from 0 to HiddenNodes-1                                              ' Initialize HiddenWeights and ChangeHiddenWeights
    tindex := 0
    repeat j from 0 to InputNodes
      fChangeHiddenWeights[tindex+i] := 0.0
      fHiddenWeights[tindex+i] := float(rand(128)-64) /. 64.0 *. long[@fInitialWeightMax]
      tindex += HiddenNodes

  repeat i from 0 to OutputNodes-1                                              ' Initialize OutputWeights and ChangeOutputWeights
    tindex := 0
    repeat j from 0 to HiddenNodes
      fChangeOutputWeights[tindex+i] := 0.0
      fOutputWeights[tindex+i] := float(rand(128)-64) /. 64.0 *. long[@fInitialWeightMax]
      tindex += OutputNodes

  start := getms()
  repeat TrainingCycle from 1 to 2147483647-1                                   ' Begin training

    repeat p from 0 to PatternCount-1                                           ' Randomize order of training data
      q := rand(PatternCount)
      RandomizedIndex[p], RandomizedIndex[q] := RandomizedIndex[q], RandomizedIndex[p]

    fError := 0.0
    repeat q from 0 to PatternCount-1                                           ' Cycle through each training pattern in the randomized order
      p := RandomizedIndex[q]

      tindex := InputNodes*HiddenNodes                                          ' Compute hidden layer activations
      repeat i from 0 to HiddenNodes-1
        fAccum := fHiddenWeights[tindex+i]
        t1index := 0
        repeat j from 0 to InputNodes-1
          fAccum := fAccum +. long[@fInput][(InputNodes*p)+j] *. fHiddenWeights[t1index+i]
          t1index += HiddenNodes
        fHidden[i] := utilities.sigmoid(fAccum)

      tindex := HiddenNodes*OutputNodes                                         ' Compute output layer activations and calculate errors
      repeat i from 0 to OutputNodes-1
        fAccum := fOutputWeights[tindex+i]
        repeat j from 0 to HiddenNodes-1
          fAccum := fAccum +. fHidden[j] *. fOutputWeights[(OutputNodes*j)+i]
        fOutput[i] := utilities.sigmoid(fAccum)
        t1index := OutputNodes*p
        fOutputDelta[i] := (long[@fTarget][t1index+i] -. fOutput[i]) *. fOutput[i] *. (1.0 -. fOutput[i]) ' gradient
        diff := long[@fTarget][t1index+i] -. fOutput[i]
        fError := fError +. 0.5 *. diff *. diff                                 ' sum of MSE for these time through training data

      repeat i from 0 to HiddenNodes-1                                          ' Backpropagate errors to hidden layer
        fAccum := 0.0
        repeat j from 0 to OutputNodes-1
          fAccum := fAccum +. fOutputWeights[(OutputNodes*i)+j] *. fOutputDelta[j]
        fHiddenDelta[i] := fAccum *. fHidden[i] *. (1.0 -. fHidden[i])          ' gradient

      tindex := InputNodes*HiddenNodes                                          ' Update Inner-->Hidden Weights
      repeat i from 0 to HiddenNodes-1
        ' update to hidden bias
        fChangeHiddenWeights[tindex+i] := long[@fLearningRate] *. fHiddenDelta[i] +. long[@fMomentum] *. fChangeHiddenWeights[tindex+i]
        fHiddenWeights[tindex+i] := fHiddenWeights[tindex+i] +. fChangeHiddenWeights[tindex+i]
        repeat j from 0 to InputNodes-1
          t1index := HiddenNodes*j
          ' update to hidden weights
          fChangeHiddenWeights[t1index+i] := long[@fLearningRate] *. long[@fInput][(InputNodes*p)+j] *. fHiddenDelta[i] +. long[@fMomentum] *. fChangeHiddenWeights[t1index+i]
          fHiddenWeights[t1index+i] := fHiddenWeights[t1index+i] +. fChangeHiddenWeights[t1index+i]

      tindex := HiddenNodes*OutputNodes                                         ' Update Hidden-->Output Weights
      repeat i from 0 to OutputNodes-1
        fChangeOutputWeights[tindex+i] := long[@fLearningRate] *. fOutputDelta[i] +. long[@fMomentum] *. fChangeOutputWeights[tindex+i]
        ' update to output bias
        fOutputWeights[tindex+i] := fOutputWeights[tindex+i] +. fChangeOutputWeights[tindex+i]
        repeat j from 0 to HiddenNodes-1
          t1index := OutputNodes*j
          fChangeOutputWeights[t1index+i] := long[@fLearningRate] *. fHidden[j] *. fOutputDelta[i] +. long[@fMomentum] *. fChangeOutputWeights[t1index+i]
          ' update to output weights
          fOutputWeights[t1index+i] := fOutputWeights[t1index+i] +. fChangeOutputWeights[t1index+i]

    debug(`MyXY `((TrainingCycle*50-80_000),round(fError*.160_000.0)-80_000))

    if fError < long[@fSuccess]                                                 ' If error rate is less than pre-determined threshold then end
      quit

  start := getms() - start
  debug("Stop training ", udec(TrainingCycle), " total:", udec_(start), "ms, time:", udec_(start/TrainingCycle), "ms, ", fdec(fError))

  ' print out the weights to paste into nn_drive.spin2
  debug("fHiddenWeights")
  repeat i from 0 to ((InputNodes + 1)*HiddenNodes)-1
    debug(if((i+//HiddenNodes==0) and (i<>0)), " ")
    debug("long ", fdec_(fHiddenWeights[i]))
  debug("fEndHiddenWeights")
  debug(" ")
  debug("fOutputWeights")
  repeat i from 0 to ((HiddenNodes + 1)*OutputNodes)-1
    debug(if((i+//OutputNodes==0) and (i<>0)), " ")
    debug("long ", fdec_(fOutputWeights[i]))
  debug("fEndOutputWeights")
'