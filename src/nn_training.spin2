{ Neural Network
  port of
        http://robotics.hobbizine.com/arduinoann.html

  provides training capability for nn_drive
  but recommend use
          https://github.com/timmoore/propbot/trainer
}

CON
PatternCount    = 6
InputNodes      = 5
HiddenNodes     = 6
OutputNodes     = 2

OBJ
    utilities   : "utilities"

DAT
fLearningRate            long 0.3
fMomentum                long 0.9
fInitialWeightMax        long 0.5
fSuccess                 long 0.0015

fInput {[PatternCount][InputNodes]}
  long 0.0, 0.0, 0.0, 0.0, 0.0
  long 1.0, 1.0, 1.0, 1.0, 1.0
  long 0.0, 0.0, 1.0, 0.0, 0.0
  long 0.0, 1.0, 1.0, 1.0, 0.0
  long 0.5, 0.5, 0.5, 0.5, 0.5
  long 0.0, 0.0, 0.5, 0.0, 0.0

fTarget {[PatternCount][OutputNodes]}
  long 1.0, 1.0
  long 0.0, 0.0
  long 0.6, 0.7
  long 0.8, 0.2
  long 0.6, 0.6
  long 0.5, 0.6

VAR
  long fError
  long prog_start

  long i, j
  long fAccum
  long p, q
  long ReportEvery100
  long TrainingCycle
  long fRando

  long RandomizedIndex[PatternCount]

  long fHiddenDelta[HiddenNodes]

  long fOutputDelta[OutputNodes]

  long fHiddenWeights[(InputNodes + 1)*HiddenNodes]
  long fChangeHiddenWeights[(InputNodes + 1)*HiddenNodes]

  long fChangeOutputWeights[(HiddenNodes + 1)*OutputNodes]
  long fOutputWeights[(HiddenNodes + 1)*OutputNodes]

  long fOutput[OutputNodes]
  long fHidden[HiddenNodes]

pub null()

pub start()
  fError := 2.0

  ReportEvery100 := 1
  repeat p from 0 to PatternCount-1
    RandomizedIndex[p] := p

pri rand(r) : result
  if r == 16
    result := getrnd() & $0f
  elseif r == 128
    result := getrnd() & $7f
  else
    result := getrnd() +// r

pub train_nn() | t, t1
'TRAINS THE NEURAL NETWORK
  debug("Start training")

  debug("exp test1 ", fdec(utilities.sigmoid(10.0)))
  debug("exp test2 ", fdec(utilities.sigmoid(-5.0)))
  debug("exp test3 ", fdec(utilities.sigmoid(-440.0)))
  debug("exp test4 ", fdec(utilities.sigmoid(55.0)))
  debug(`SCOPE_XY MyXY SIZE 120 COLOR black black RANGE 100_000 SAMPLES 0 'MSE')
  prog_start := 0
  debug("training init ", sdec(HiddenNodes), " ", sdec(InputNodes))

  ' Initialize HiddenWeights and ChangeHiddenWeights
  'float ChangeHiddenWeights[InputNodes + 1][HiddenNodes];
  'long fChangeHiddenWeights[(InputNodes + 1)*HiddenNodes]
  'float HiddenWeights[InputNodes + 1][HiddenNodes];
  'long fHiddenWeights[(InputNodes + 1)*HiddenNodes]
  repeat i from 0 to HiddenNodes-1
    repeat j from 0 to InputNodes
      t := HiddenNodes*j
      fChangeHiddenWeights[t+i] := 0.0
      fRando := float(rand(128)) /. 128.0
      fHiddenWeights[t+i] := 2.0 *. (fRando -. 0.5) *. long[@fInitialWeightMax]
      'debug("rand pattern ", sdec(i), " ", sdec(j), " ", sdec(t), " ", fdec(fChangeHiddenWeights[t+i]), " ", fdec(fHiddenWeights[t+i]))

  ' Initialize OutputWeights and ChangeOutputWeights
  ' float ChangeOutputWeights[HiddenNodes + 1][OutputNodes];
  ' float OutputWeights[HiddenNodes + 1][OutputNodes];
  debug("training init1 ", sdec(OutputNodes), " ", sdec(HiddenNodes))
  repeat i from 0 to OutputNodes-1
    repeat j from 0 to HiddenNodes
      t := OutputNodes*j
      fChangeOutputWeights[t+i] := 0.0
      fRando := float(rand(128)) /. 128.0
      fOutputWeights[t+i] := 2.0 *. (fRando -. 0.5) *. long[@fInitialWeightMax]
      'debug("rand pattern1 ", sdec(i), " ", sdec(j), " ", sdec(t), " ", fdec(fChangeOutputWeights[t+i]), " ", fdec(fOutputWeights[t+i]))

  ' Begin training
  repeat TrainingCycle from 1 to 2147483647-1
    'debug("training cycle")

    'debug("training cycle1 ", sdec(PatternCount))
    ' Randomize order of training patterns
    repeat p from 0 to PatternCount-1
      q := rand(PatternCount)
      RandomizedIndex[p], RandomizedIndex[q] := RandomizedIndex[q], RandomizedIndex[p]
    fError := 0.0
    'debug("training cycle1a ", sdec(p), " ", sdec(q), " ", sdec(r))

    'debug("training cycle2 ", sdec(PatternCount), " ", fdec(Error))

    ' Cycle through each training pattern in the randomized order
    repeat q from 0 to PatternCount-1
      p := RandomizedIndex[q]

      'debug("training cycle3 ", sdec(HiddenNodes), " ", fdec(Error))
      ' Compute hidden layer activations
      'float HiddenWeights[InputNodes + 1][HiddenNodes];
      t := InputNodes*HiddenNodes
      repeat i from 0 to HiddenNodes-1
        fAccum := fHiddenWeights[t+i]
        repeat j from 0 to InputNodes-1
          fAccum := fAccum +. long[@fInput][(InputNodes*p)+j] *. fHiddenWeights[(HiddenNodes*j)+i]
        fHidden[i] := utilities.sigmoid(fAccum)
      'debug("training cycle4 ", sdec(OutputNodes), " ", fdec(Error))

      ' Compute output layer activations and calculate errors
      'float OutputWeights[HiddenNodes + 1][OutputNodes];
      t := HiddenNodes*OutputNodes
      repeat i from 0 to OutputNodes-1
        fAccum := fOutputWeights[t+i]
        repeat j from 0 to HiddenNodes-1
          fAccum := fAccum +. fHidden[j] *. fOutputWeights[(OutputNodes*j)+i]
        fOutput[i] := utilities.sigmoid(fAccum)
        t1 := OutputNodes*p
        fOutputDelta[i] := (long[@fTarget][t1+i] -. fOutput[i]) *. fOutput[i] *. (1.0 -. fOutput[i])
        fError := fError +. 0.5 *. (long[@fTarget][t1+i] -. fOutput[i]) *. (long[@fTarget][t1+i] -. fOutput[i])

      'debug("training cycle5 ", sdec(HiddenNodes), " ", fdec(Error))
      ' Backpropagate errors to hidden layer
      'float OutputWeights[HiddenNodes + 1][OutputNodes];
      repeat i from 0 to HiddenNodes-1
        fAccum := 0.0
        repeat j from 0 to OutputNodes-1
          fAccum := fAccum +. fOutputWeights[(OutputNodes*i)+j] *. fOutputDelta[j]
        fHiddenDelta[i] := fAccum *. fHidden[i] *. (1.0 -. fHidden[i])

      'debug("training cycle6 ", sdec(HiddenNodes), " ", fdec(Error))
      ' Update Inner-->Hidden Weights
      'float ChangeHiddenWeights[InputNodes + 1][HiddenNodes];
      'float HiddenWeights[InputNodes + 1][HiddenNodes];
      t := InputNodes*HiddenNodes
      repeat i from 0 to HiddenNodes-1
        fChangeHiddenWeights[t+i] := long[@fLearningRate] *. fHiddenDelta[i] +. long[@fMomentum] *. fChangeHiddenWeights[t+i]
        fHiddenWeights[t+i] := fHiddenWeights[t+i] +. fChangeHiddenWeights[t+i]
        repeat j from 0 to InputNodes-1
          t1 := HiddenNodes*j
          fChangeHiddenWeights[t1+i] := long[@fLearningRate] *. long[@fInput][(InputNodes*p)+j] *. fHiddenDelta[i] +. long[@fMomentum] *. fChangeHiddenWeights[t1+i]
          fHiddenWeights[t1+i] := fHiddenWeights[t1+i] +. fChangeHiddenWeights[t1+i]

      'debug("training cycle7 ", sdec(OutputNodes), " ", fdec(Error))
      ' Update Hidden-->Output Weights
      'float ChangeOutputWeights[HiddenNodes + 1][OutputNodes];
      'float OutputWeights[HiddenNodes + 1][OutputNodes];
      t := HiddenNodes*OutputNodes
      repeat i from 0 to OutputNodes-1
        fChangeOutputWeights[t+i] := long[@fLearningRate] *. fOutputDelta[i] +. long[@fMomentum] *. fChangeOutputWeights[t+i]
        fOutputWeights[t+i] := fOutputWeights[t+i] +. fChangeOutputWeights[t+i]
        repeat j from 0 to HiddenNodes-1
          t1 := OutputNodes*j
          fChangeOutputWeights[t1+i] := long[@fLearningRate] *. fHidden[j] *. fOutputDelta[i] +. long[@fMomentum] *. fChangeOutputWeights[t1+i]
          fOutputWeights[t1+i] := fOutputWeights[t1+i] +. fChangeOutputWeights[t1+i]

    ' Every 100 cycles send data to terminal for display
    ReportEvery100 := ReportEvery100 - 1
    if ReportEvery100 == 0

      'debug("TrainingCycle: ", sdec(TrainingCycle), " Error: ", sdec(Error))
      debug(`MyXY `(TrainingCycle/100-100_000,round(fError*.100_000.0)))

      ReportEvery100 := (TrainingCycle == 1)? 99 : 100

    ' If error rate is less than pre-determined threshold then end
    if fError < long[@fSuccess]
      quit

  debug("Stop training ", udec(TrainingCycle), " ", fdec(fError))
  debug("fHiddenWeights")
  repeat i from 0 to ((InputNodes + 1)*HiddenNodes)-1
    debug("long ", fdec_(fHiddenWeights[i]))
  debug("fEndHiddenWeights")

  debug("fOutputWeights")
  repeat i from 0 to ((HiddenNodes + 1)*OutputNodes)-1
    debug("long ", fdec_(fOutputWeights[i]))
  debug("fEndOutputWeights")
'