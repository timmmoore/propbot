{ Utilities
                timmoore
}

OBJ
'  serial        : "isp_serial_singleton_tmm"

PUB null()
  ' This is not a top-level object

PUB wrapangles(angle1, angle2, maxangle) : deltaangle | d1
  ' find the smallest angle between request and current angles, moving in either direction, allowing for wrapround
  ' maxangle must be +ve
  d1 := deltaangle := angle2 - angle1
  if abs(deltaangle) > (maxangle>>1)
    deltaangle := (deltaangle > 0)?-maxangle + deltaangle:+maxangle + deltaangle
  'serial.fstr4(string("wrapangles c:%d s:%d %d %d\r"), angle1, angle2, d1, deltaangle)

PUB map(value, inmin, inmax, outmin, outmax) : result
'' Maps value in range inmin..inmax to new value in range outmin..outmax
  value := inmin #> value <# inmax
  result := (value - inmin) * (outmax - outmin) / (inmax - inmin) + outmin

PUB clamp(input, tmaxinput) : s
' +- max clamp
  s := -tmaxinput #> input <# tmaxinput

PUB fullclamp(input, tmininput, tmaxinput) : s
' separate min and max clamping values
  s := tmininput #> input <# tmaxinput                  ' greater= min; less= max

PUB longcomp(p1, p2, count, diff, update) : retv
' return true if p1 and p2 not the same with greater then diff delta
  repeat count with retv
    if abs(long[p1][retv] - long[p2][retv]) > diff
      quit
  if (retv := retv < count) && (update <> false)
    longmove(p1, p2, count)

PUB longcompf(p1, p2, count, diff, update) : retv
' return true if p1 and p2 not the same with float precision with greater than diff delta
  repeat count with retv
    if fabs(long[p1][retv] -. long[p2][retv]) >. diff
      quit
  if (retv := retv < count) && (update <> false)
    longmove(p1, p2, count)

PUB maxlong(pinput, count, inc) : highest | index, temp
' find maximum absolute value
  repeat index from 0 to count-1 step inc
    if (temp := abs(long[pinput][index])) > highest
      highest := temp

PUB swapbytes(val) : result
' reverse order of bytes in a long
  org
    mov     result, val
    movbyts result, #%%0123
  end

con
  ' debug switches are 3 position switchs: 500, 1250 and 2000
  DEBUG1_OUTPUT     =           500
  DEBUG2_OUTPUT     =           1000
  DEBUG3_OUTPUT     =           1200
  DEBUG4_OUTPUT     =           2000

  DEBUGNONE       = 0
  DEBUGOUT1       = 1                                   ' lower position outputs DEBUG1_OUTPUT only
  DEBUGOUT2       = 2
  DEBUGOUT3       = 3                                   ' middle position outputs DEBUG1_OUTPUT-DEBUG3_OUTPUT
  DEBUGOUT4       = 4                                   ' upper position outputs DEBUG1_OUTPUT-DEBUG4_OUTPUT

PUB debugoutput(debug1, type) : retv
  if type > 0 and type <= 4
    retv := debug1 >= debugtypes[type-1]

dat
  debugtypes long  DEBUG1_OUTPUT, DEBUG2_OUTPUT, DEBUG3_OUTPUT, DEBUG4_OUTPUT

PUB add64(xl, xh, x) : rxl, rxh
' 64bit + 32bit signed add
  longmove(@rxl, @xl, 2)

  org
    add   rxl, x                  wc
    addsx rxh, #0
  end

pub cart_pol(x, y) : r, t
'' Convert coordinate x,y to polar (length, angle (0.1deg))
' from forums
  org
    qvector   x, y                                      ' cartesian to polar
    getqx     r                                         ' get radius (length)
    getqy     t                                         ' get theta (angle)
    qdiv      t, ##1193046                              ' convert angle to 0.1 degree units, $ffffffff/1193046 -> 3600
    getqx     t
  end
'
CON
  fposlimitfull    = 7.0                                ' 16.619047165
  fneglimitfull    = -7.0

' equilivalent
'   return 1.0/(1.0 + exp(-x))
'
pub sigmoid_full(fin) : result | fsum, fterm, fterm1, fterm2, fterm3, fterm4, fterm5, fterm6, fterm7, fterm8
' output range 0 to +1
  fin := -.fin
                                                        ' make sure in range for the tayor series to converge
  if fin >. fposlimitfull                               ' >. handle upper limit
    result := 1.0
  elseif fin <. fneglimitfull                           ' <. handle lower limit
    result := 0.0
  else
    fterm  := fin *. (fin /. 2.0)                       ' tayor series for exp
    fterm1 := fterm *. (fin /. 3.0)
    fterm2 := fterm1 *. (fin /. 4.0)
    fterm3 := fterm2 *. (fin /. 5.0)
    fterm4 := fterm3 *. (fin /. 6.0)
    fterm5 := fterm4 *. (fin /. 7.0)
    fterm6 := fterm5 *. (fin /. 8.0)
    fterm7 := fterm6 *. (fin /. 9.0)
    fterm8 := fterm7 *. (fin /. 10.0)
    fsum := fin +. fterm +. fterm1 +. fterm2 +. fterm3 +. fterm4 +. fterm5 +. fterm6 +. fterm7 +. fterm8
    result := 1.0 /. (2.0 +. fsum)

CON
  fposlimit                     = 16.0
'
' approx log_w_approx_exp_no_overflow16_clamped
' see https://scicomp.stackexchange.com/questions/42186/faster-logistic-function
'       if x >= 16
'         sigmod = 1
'       else
'         sigmoid = 1/(1 + (1-x/16)^16)
'
pub sigmoid(fin) : result
' output range 0 to +1
                                                        ' make sure in range for the tayor series to converge
  if fin >=. fposlimit
    result := 1.0
  else
    result := x16(fin)                                  ' n = 16, so (1-fin/16)^16

pub sigmoidDer(fin) : result
' Derivate for sigmoid
'   (x - x^2) -> x(1-x)
  result := fin *. (1.0 -. fin)

pub x16a(fin) : result
' 13.1us
    fin := 1.0 -. fin /. 16.0                           ' 1-fin/16
    fin := fin *. fin                                   ' ^2
    fin := fin *. fin                                   ' ^4
    fin := fin *. fin                                   ' ^8
    result := 1.0 /. (1.0 +. (fin *. fin))              ' 1.0 /. (1.0 + fin^16)

pub x16(fx) : result | ma, sa, na, xa, y, mb, mc, md, me, xb, xc, xd, xe, c
' 6.6us
' result := 1.0 /. (1.0 +. (1.0 -. x /. 16.0)^16)
'
  ma := fx                                              ' packed float
  me := md := mc := mb := $2000_0000                    ' b-d=1.0 and e=16.0
  xd := xc := xb := 0                                   ' 1.0
  xe := 4                                               ' 16.0
  org
                bitl    ma,#31          wcz     'read and clear sign
                wrc     sa

                cmpr    ma,##$7F800000  wc      'check for NaN
                wrc     na

                mov     xa,ma                   'get exponent
                shr     xa,#32-1-8      wz

                zerox   ma,#22                  'get mantissa

        if_nz   bith    ma,#23                  'if exponent <> 0 then insert leading one
        if_nz   shl     ma,#29-23               '...bit29-justify mantissa

        if_z    encod   xa,ma                   'if exponent = 0 then get magnitude of mantissa
        if_z    ror     ma,xa                   '...bit29-justify mantissa
        if_z    ror     ma,#32-29

                shr     ma,#1                   'make ma < mb
                qfrac   ma,me                   'compute quotient of (ma << 32) / mb

        if_z    sub     xa,#22                  '...adjust exponent to -22..0

                sub     xa,#127                 'unbias exponent
'
' ma /. 16.0
'
                sub     xa, xe                  'subtract exponents

                getqx   ma
                shr     ma,#2                   'justify quotient
'
' 1.0 -. ma /. 16.0
'
                test    sa              wz      'negate ma?
                negz    ma

                mov     y,xa                    'determine greater exponent
                subs    y,xd            wcz     'xa > xb ?

                abs     y                       'absolutize and clamp exponent difference
                fle     y,#31

        if_a    sar     md,y                    'shift lower-exponent mantissa down
        if_be   sar     ma,y
        if_be   mov     xa,xd

                add     ma,md                   'add mantissas
                abs     ma              wc      'absolutize result
'
' mul
'   (1.0 -. ma /. 16.0)^16
'
                qmul    ma,ma                   'compute upper product of ma * ma
                wrc     sa                      'set sign
                add     xa,xa                   'add exponents
                getqy   ma
                shl     ma,#3                   'justify product
                test    ma, ##$C000_0000  wz
          if_nz shr     ma,#2
                qmul    ma,ma                   'compute upper product of ma * ma
          if_nz add     xa,#2
                add     xa,xa                   'add exponents
                getqy   ma
                shl     ma,#3                   'justify product
                test    ma, ##$C000_0000  wz
          if_nz shr     ma,#2
                qmul    ma,ma                   'compute upper product of ma * ma
          if_nz add     xa,#2
                add     xa,xa                   'add exponents
                getqy   ma
                shl     ma,#3                   'justify product
                test    ma, ##$C000_0000  wz
          if_nz shr     ma,#2
                qmul    ma,ma                   'compute upper product of ma * ma
          if_nz add     xa,#2
                add     xa,xa                   'add exponents
                getqy   ma
                shl     ma,#3                   'justify product
                test    ma, ##$C000_0000  wz
          if_nz shr     ma,#2
          if_nz add     xa,#2
'
'   1.0 +. (1.0 -. ma /. 16.0)^16
'
                mov     y,xa                    'determine greater exponent
                subs    y,xb            wcz     'xa > xb ?

                abs     y                       'absolutize and clamp exponent difference
                fle     y,#31

          if_a  sar     mb,y                    'shift lower-exponent mantissa down
          if_be sar     ma,y
          if_be mov     xa,xb

                add     ma,mb                   'add mantissas
                abs     ma              wc      'absolutize result
                wrc     sa                      'set sign
'
'   1.0 /. (1.0 +. (1.0 -. ma /. 16.0)^16)
                shr     mc,#1                   'make ma < mb
                mov     c, #8
.msb
                testb   ma,#31          wc
          if_nc shl     ma,#1
          if_nc sub     xa,#1
                djnz    c, #.msb

                qfrac   mc,ma                   'compute quotient of (ma << 32) / mb

                subr    xa, xc                  'subtract exponents

                testbn  na,#0           wc      'if NaN, result $FFFFFFFF

                getqx   ma
                shr     ma,#2                   'justify quotient
'
' Pack float            na,sa,xa,ma --> float ma
'
        if_nc   not     ma,#0

        if_c    encod   y,ma            wc      'determine magnitude of mantissa
        if_nc   ret                             'if NaN or mantissa=0 (result 0), done

                ror     ma,y                    'msb-justify mantissa without leading 1
                bitl    ma,#0                   'clear leading 1 now in lsb

                mov     mb,ma                   'check if mantissa is even with 0.500 fraction
                zerox   mb,#9           wc      'clear msb's, c=0 for addx in case no rounding
                cmp     mb,#%0100000000 wz      'even with 0.500 fraction?
        if_nz   add     ma,#%0100000000 wc      'if not, round up mantissa by 0.500

                addx    xa,y                    'adjust exponent and account for rounding overflow
                add     xa,#127-29              'bias exponent

                fges    xa,##-23                'limit exponent to -23..255
                fles    xa,#255         wc      'if 255 and mantissa not 0, NaN
        if_c    not     ma,#0                   'if >255, force Nan by making mantissa not 0

                cmps    xa,#1           wc      'exponent < 1?

        if_c    rcr     ma,#1                   'if so, replace leading 1
        if_c    neg     xa                      'shift mantissa down by exponent
        if_c    shr     ma,xa                   'if exponent is -23, mantissa becomes 0

                shr     ma,#8                   'make room for exponent
        if_nc   setbyte ma,xa,#3                'if exponent < 1 then leave at 0, else install

                testb   sa,#0           wc      'install sign bit
                rcr     ma,#1
  end
  result := ma
'
con { license }
{{

  Terms of Use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

}}