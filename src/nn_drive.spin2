{ Neural Network
  port of
        http://robotics.hobbizine.com/arduinoann.html
  Also read
        https://mattmazur.com/2015/03/17/a-step-by-step-backpropagation-example/

  Only drive capability to train and generate NN weights
        https://github.com/timmoore/propbot/trainer
}

CON
' need to match training data and generated weights
InputNodes      = 5                                                             ' input nodes,1 per lidar input
HiddenNodes     = 6                                                             ' hidden nodes
OutputNodes     = 2                                                             ' output nodes, 1 per motor

OBJ
  utilities     : "utilities"

VAR
  long fInput[InputNodes]                                                       ' input values
  long fHidden[HiddenNodes]                                                     ' hidden values
  long fOutput[OutputNodes]                                                     ' output values

DAT
' training data from Spin2_weight_trainer
' run the training data using the Spin2_weight_trainer. Copy and paste the results here
'
' The first are weights for the hidden nodes:  (InputNodes+1)  * HiddenNodes
' The second are weights for the output nodes: (HiddenNodes+1) * OutputNodes
'
fHiddenWeights
long -0.8779296875
long  1.34375
long  -1.576171875
long  -1.3125
long  0.0219268798828125
long  0.853515625

long  0.355712890625
long  -1.0
long  -0.57080078125
long  1.0
long  -1.1728515625
long  0.84765625

long  -1.0
long  1.1328125
long  -1.515625
long  -1.0869140625
long  -1.423828125
long  1.14453125

long  -0.30322265625
long  -1.0
long  0.82177734375
long  0.391845703125
long  -1.0947265625
long  0.53076171875

long  -0.471923828125
long  0.9580078125
long  -0.724609375
long  -1.875
long  -0.79248046875
long  0.62255859375

long  0.311767578125
long  -0.264892578125
long  1.0185546875
long  0.8857421875
long  1.4091796875
long  -1.296875
fEndHiddenWeights
fOutputWeights
long 1.3447265625
long  0.70654296875

long  -2.455078125
long  -0.10870361328125

long  2.189453125
long  2.0

long  2.9375
long  0.7998046875

long  0.99951171875
long  3.00390625

long  -1.6171875
long  -2.9765625

long  -0.59521484375
long  -0.99951171875
fEndOutputWeights

pub null()

pub start() : result
' 0 is ok
  ' size of weight table must match expected based on node sizes
  if (@fEndHiddenWeights-@fHiddenWeights)/4 <> (InputNodes+1)*HiddenNodes
    debug(" Hidden weight size mis-match ", udec((fEndHiddenWeights-fHiddenWeights)/4), " ", udec((InputNodes+1)*HiddenNodes))
    return 1
  if (@fEndOutputWeights-@fOutputWeights)/4 <> (HiddenNodes + 1)*OutputNodes
    debug(" Output weight size mis-match ", udec((fEndOutputWeights-fOutputWeights)/4), " ", udec((HiddenNodes + 1)*OutputNodes))
    return 2
  return 0

pub drive_nn(pInput, pOutput) | index, pout
' translate between demo_dual_motor_rc input/output
'   input: boolean, lidar detection (L, FL, F, FR, R)
'   output: -100 to 100, left/right motor speed
' 583us / 355us with approx sigmoid
  repeat index from 0 to InputNodes-1
    fInput[index] := long[pInput][index]? 1.0 : 0.0                             ' convert boolean inputs to float 0.0, 1.0

  pout := InputToOutput(@fInput)                                                ' input to NN to obtain output

  repeat index from 0 to OutputNodes-1
    long[pOutput][index] := round(long[pout][index] *. 200.0) - 100             ' convert 0 -> +1 to -100 to 100
  'debug(" out1 ", sdec_long_array(pOutput, OutputNodes))

pri InputToOutput(pfTestInput) : poutput | tempindex, tempindex1, outer, inner, faccum
' core of the neutral network
' input nodes are  5: 0.0/1.0 assumption is true if something left/front-left, front, front-right, right
' output nodes are 2: 0.0-1.0 left/right motor 0 is full speed backwards, 0.5 is stopped, 1.0 is full speed forwards
' hidden nodes are 6
'
' cordic operations (1 multiply)*(inputnodes + outputnodes)*hiddennodes
'                   hiddennodes+outputnode * sigmoid 9 * (1 multiply, 1 divide) + 1 divide
'                   hiddennodes+outputnode * approx sigmoid 4 multiply, 2 divide
' total = 114 multiply, 80 divide, ~130us, so 22% of excution time
' total approx = 72 multiply, 16 divide, ~59us, so 17% of excution time
'
  ' Compute hidden layer activations
  ' float HiddenWeights[InputNodes + 1][HiddenNodes]                            ' weight per input node per hidden node
  tempindex := InputNodes*HiddenNodes                                           ' bias is handled as an extra input node
  repeat outer from 0 to HiddenNodes-1
    faccum := long[@fHiddenWeights][tempindex++]                                ' bias to start adding up weights
    tempindex1 := outer
    repeat inner from 0 to InputNodes-1
      faccum := faccum +. (long[pfTestInput][inner] *. long[@fHiddenWeights][tempindex1]) ' sum of weights per hidden node per input node
      tempindex1 += HiddenNodes                                                 ' next hidden node
    fHidden[outer] := utilities.sigmoid(faccum)                                 ' total per hidden node, curve flattened using logistic function

  ' Compute output layer activations
  ' float OutputWeights[HiddenNodes + 1][OutputNodes];                          ' weight per hidden node per output node
  tempindex := HiddenNodes*OutputNodes                                          ' bias is handled as an extra hidden node
  repeat outer from 0 to OutputNodes-1
    faccum := long[@fOutputWeights][tempindex++]                                ' bias
    tempindex1 := outer
    repeat inner from 0 to HiddenNodes-1
      faccum := fAccum +. (fHidden[inner] *. long[@fOutputWeights][tempindex1]) ' sum of weights per output node per hidden node
      tempindex1 += OutputNodes
    fOutput[outer] := utilities.sigmoid(faccum)                                 ' total per output node, curve flattened using logistic function

  return @fOutput
'
VAR
  byte disp[6]

DAT
lidardisp   byte "L#F#R", 0

PUB updatedisplaylidar(pin) : result | i
' convert lidar detection into displayable string
  strcopy(@disp, @lidardisp, 5)
  repeat i from 0 to 4
    ifnot long[pin][i]
      disp[i] := " "
  return @disp

' set of tests that run the Lidar simultated inputs through the neutral network and prints the results
'
DAT
testinputs
        long false, false, false, false, false          ' test1
        long  true,  true,  true,  true,  true          ' test2
        long false, false,  true, false, false          ' test3
        long false,  true,  true,  true, false          ' test4
        long  true,  false, true, false,  true          ' test5
        long  true,  true,  true, false, false          ' test6
        long false, false,  true,  true,  true          ' test7
        long  true,  true,  true,  true, false          ' test8
endtestinputs

pub test_nn() | ptest, nout[2], i, t, clk
' run set of tests on nn
'
  clk := clkfreq/1_000_000
  repeat i from 0 to ((@endtestinputs - @testinputs)/(4*5))-1
    ptest := @long[@testinputs][5*i]
    t := getct()
    drive_nn(ptest, @nout)
    t := getct() - t
    debug("test", udec_(i+1), " ", udec_(t/clk), "us lidar=(", zstr_(updatedisplaylidar(ptest)), ") motors= ", sdec_long_array_(@nout, 2))
'