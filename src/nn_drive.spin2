{ Neural Network
  port of
        http://robotics.hobbizine.com/arduinoann.html
  Also read
        https://mattmazur.com/2015/03/17/a-step-by-step-backpropagation-example/

  Only drive capability to train and generate NN weights
        https://github.com/timmoore/propbot/trainer
}

CON
' need to match training data and generated weights
InputNodes      = 5
HiddenNodes     = 6
OutputNodes     = 2

OBJ
  utilities     : "utilities"

VAR
  long fOutput[OutputNodes]
  long fHidden[HiddenNodes]

DAT
' training data from Spin2_weight_trainer
fHiddenWeights
long -1.205078125
long  0.54443359375
long  -1.578125
long  -1.2666015625
long  -1.525390625
long  -0.8115234375

long  0.3115234375
long  1.017578125
long  1.1796875
long  1.3994140625
long  0.8623046875
long  -1.0263671875

long  -2.0
long  1.142578125
long  -1.0947265625
long  -0.8046875
long  -1.068359375
long  -1.25

long  -0.494873046875
long  0.4853515625
long  0.194580078125
long  0.50048828125
long  0.18994140625
long  -0.68505859375

long  -1.447265625
long  1.0
long  -1.046875
long  -1.1220703125
long  -1.0
long  -0.095703125

long  1.4345703125
long  -0.8056640625
long  0.50048828125
long  -0.0955810546875
long  0.54833984375
long  1.0

fEndHiddenWeights
fOutputWeights
long 2.42578125
long  3.037109375

long  -1.8486328125
long  -2.703125

long  2.248046875
long  0.83154296875

long  2.0
long  -0.455322265625

long  2.0
long  0.8115234375

long  0.72119140625
long  2.38671875

long  -2.216796875
long  -1.029296875

fEndOutputWeights

pub null()

pub start() : result
' 0 is ok
  ' size of weight table must match expected based on node sizes
  if (@fEndHiddenWeights-@fHiddenWeights)/4 <> (InputNodes+1)*HiddenNodes
    debug(" Hidden weight size mis-match ", udec((fEndHiddenWeights-fHiddenWeights)/4), " ", udec((InputNodes+1)*HiddenNodes))
    return 1
  if (@fEndOutputWeights-@fOutputWeights)/4 <> (HiddenNodes + 1)*OutputNodes
    debug(" Output weight size mis-match ", udec((fEndOutputWeights-fOutputWeights)/4), " ", udec((HiddenNodes + 1)*OutputNodes))
    return 2
  return 0

VAR
  long fTestInput[InputNodes]

pub drive_nn(pInput, pOutput) | index, pout
' input: boolean, lidar detection (L, FL, F, FR, R)
' output: -100 to 100, left/right motor speed

  repeat index from 0 to InputNodes-1
    fTestInput[index] := long[pInput][index]? 1.0 : 0.0                         ' convert boolean inputs to float 0.0, 1.0

  pout := InputToOutput(@fTestInput)                                            ' input to NN to obtain output

  repeat index from 0 to OutputNodes-1
    long[pOutput][index] := round(long[pout][index] *. 200.0) - 100             ' convert 0 -> +1 to -100 to 100
  'debug(" out1 ", sdec_long_array(pOutput, OutputNodes))

pri InputToOutput(pfTestInput) : poutput | tempindex, tempindex1, outer, inner, faccum

  ' Compute hidden layer activations
  ' float HiddenWeights[InputNodes + 1][HiddenNodes]
  tempindex := InputNodes*HiddenNodes
  repeat outer from 0 to HiddenNodes-1
    faccum := long[@fHiddenWeights][tempindex++]
    tempindex1 := outer
    repeat inner from 0 to InputNodes-1
      faccum := faccum +. (long[pfTestInput][inner] *. long[@fHiddenWeights][tempindex1])
      tempindex1 += HiddenNodes
    fHidden[outer] := utilities.sigmoid(faccum)

  ' Compute output layer activations and calculate errors
  ' float OutputWeights[HiddenNodes + 1][OutputNodes];
  tempindex := HiddenNodes*OutputNodes
  repeat outer from 0 to OutputNodes-1
    faccum := long[@fOutputWeights][tempindex++]
    tempindex1 := outer
    repeat inner from 0 to HiddenNodes-1
      faccum := fAccum +. (fHidden[inner] *. long[@fOutputWeights][tempindex1])
      tempindex1 += OutputNodes
    fOutput[outer] := utilities.sigmoid(faccum)

  return @fOutput
'
VAR
  byte disp[6]

DAT
lidardisp   byte "L#F#R", 0

PUB updatedisplaylidar(pin) : result | i
' convert lidar detection into displayable string
  strcopy(@disp, @lidardisp, 5)
  repeat i from 0 to 4
    ifnot long[pin][i]
      disp[i] := " "
  return @disp

DAT
testinputs
        long false, false, false, false, false          ' test1
        long  true,  true,  true,  true,  true          ' test2
        long false, false,  true, false, false          ' test3
        long false,  true,  true,  true, false          ' test4
        long  true,  false, true, false,  true          ' test5
        long  true,  true,  true, false, false          ' test6
        long false, false,  true,  true,  true          ' test7
        long  true,  true,  true,  true, false          ' test8
endtestinputs

pub test_nn() | btest[5], nout[2], i
' run set of tests on nn
'
  repeat i from 0 to ((@endtestinputs - @testinputs)/(4*5))-1
    longmove(@btest, @long[@testinputs][5*i], 5)
    drive_nn(@btest, @nout)
    debug("test", udec_(i+1), " lidar=(", zstr_(updatedisplaylidar(@btest)), ") motors= ", sdec_long_array_(@nout, 2))
'