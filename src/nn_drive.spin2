{ Neural Network
  port of
        http://robotics.hobbizine.com/arduinoann.html

  only drive capability use
        https://github.com/JonComo/Arduino_weight_trainer
}

CON
InputNodes      = 5
HiddenNodes     = 6
OutputNodes     = 2

OBJ
    utilities   : "utilities"

VAR
  long fOutput[OutputNodes]
  long fHidden[HiddenNodes]

DAT
' training data from Spin2_weight_trainer
fHiddenWeights
long -1.103515625
long  1.7958984375
long  -0.6025390625
long  -0.60107421875
long  -0.11968994140625
long  0.292724609375

long  1.38671875
long  -0.70654296875
long  -0.9033203125
long  -0.658203125
long  -0.6201171875
long  1.0

long  -1.443359375
long  0.99951171875
long  -1.1328125
long  -1.501953125
long  0.130615234375
long  1.9443359375

long  0.294189453125
long  -0.60791015625
long  -0.966796875
long  0.413330078125
long  -0.53564453125
long  0.72412109375

long  -1.533203125
long  1.408203125
long  -0.38818359375
long  -1.5078125
long  -0.2301025390625
long  0.336669921875

long  0.87841796875
long  -0.7119140625
long  1.0
long  1.244140625
long  0.250244140625
long  -1.3203125

fEndHiddenWeights
fOutputWeights
long 2.994140625
long  0.9716796875

long  -2.984375
long  -0.83056640625

long  1.306640625
long  2.26171875

long  1.9208984375
long  2.44921875

long  -0.418701171875
long  1.0

long  -1.3291015625
long  -2.884765625

long  0.30908203125
long  -0.736328125

fEndOutputWeights

pub null()

pub start() : result

  if (@fEndHiddenWeights-@fHiddenWeights)/4 <> (InputNodes+1)*HiddenNodes
    debug(" Hidden weight size mis-match ", udec((fEndHiddenWeights-fHiddenWeights)/4), " ", udec((InputNodes+1)*HiddenNodes))
    return 1
  if (@fEndOutputWeights-@fOutputWeights)/4 <> (HiddenNodes + 1)*OutputNodes
    debug(" Output weight size mis-match ", udec((fEndOutputWeights-fOutputWeights)/4), " ", udec((HiddenNodes + 1)*OutputNodes))
    return 2
  return 0

VAR
  long fTestInput[InputNodes]

VAR
  byte disp[6]

DAT
lidardisp   byte "L#F#R", 0

PRI updatedisplaylidar(pin) : result | i
' convert lidar detection into displayable string
  strcopy(@disp, @lidardisp, 5)
  repeat i from 0 to 4
    ifnot long[pin][i]
      disp[i] := " "
  return @disp

pub test_nn() | btest[5], nout[2]

  btest[0] := btest[1] := btest[2] := btest[3] := btest[4] := false
  drive_nn(@btest, @nout)
  debug("test1 ", zstr(updatedisplaylidar(@btest)), " ", sdec_long_array(@nout, 2))

  btest[0] := btest[1] := btest[2] := btest[3] := btest[4] := true
  drive_nn(@btest, @nout)
  debug("test2 ", zstr(updatedisplaylidar(@btest)), " ", sdec_long_array(@nout, 2))

  btest[0] := btest[1] := false
  btest[2] := true
  btest[3] := btest[4] := false
  drive_nn(@btest, @nout)
  debug("test3 ", zstr(updatedisplaylidar(@btest)), " ", sdec_long_array(@nout, 2))

  btest[0] := false
  btest[1] := btest[2] := btest[3] := true
  btest[4] := false
  drive_nn(@btest, @nout)
  debug("test4 ", zstr(updatedisplaylidar(@btest)), " ", sdec_long_array(@nout, 2))

pub drive_nn(pInput, pOutput) | index, pout
' input: boolean, lidar detection (L, FL, F, FR, R)
' output: -100 to 100, left/right motor speed

  repeat index from 0 to InputNodes-1
    fTestInput[index] := long[pInput][index]? 1.0 : 0.0                         ' convert boolean to float 0.0, 1.0

  pout := InputToOutput(@fTestInput)                                            ' input to NN to obtain output

  repeat index from 0 to OutputNodes-1
    long[pOutput][index] := round(long[pout][index] *. 200.0) - 100             ' convert 0 <=> +1 to -100 to 100
  'debug(" out1 ", sdec_long_array(pOutput, OutputNodes))

pri InputToOutput(pfTestInput) : poutput | tempindex, tempindex1, outer, inner, faccum

  ' Compute hidden layer activations
  ' float HiddenWeights[InputNodes + 1][HiddenNodes]
  tempindex := InputNodes*HiddenNodes
  repeat outer from 0 to HiddenNodes-1
    faccum := long[@fHiddenWeights][tempindex++]
    tempindex1 := outer
    repeat inner from 0 to InputNodes-1
      faccum := faccum +. (long[pfTestInput][inner] *. long[@fHiddenWeights][tempindex1])
      tempindex1 += HiddenNodes
    fHidden[outer] := utilities.sigmoid(faccum)

  ' Compute output layer activations and calculate errors
  ' float OutputWeights[HiddenNodes + 1][OutputNodes];
  tempindex := HiddenNodes*OutputNodes
  repeat outer from 0 to OutputNodes-1
    faccum := long[@fOutputWeights][tempindex++]
    tempindex1 := outer
    repeat inner from 0 to HiddenNodes-1
      faccum := fAccum +. (fHidden[inner] *. long[@fOutputWeights][tempindex1])
      tempindex1 += OutputNodes
    fOutput[outer] := utilities.sigmoid(faccum)

  return @fOutput
'