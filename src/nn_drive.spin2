{ Neural Network
  port of
        http://robotics.hobbizine.com/arduinoann.html
  Also read
        https://mattmazur.com/2015/03/17/a-step-by-step-backpropagation-example/

  Only drive capability

  To train and generate NN weights use either
        nn_training.spin2
  or (recommended)
        https://github.com/timmoore/propbot/trainer
}

CON
' needs to match training data and generated weights
InputNodes      = 5                                                             ' input nodes, 1 per lidar input
HiddenNodes     = 6                                                             ' hidden nodes
OutputNodes     = 2                                                             ' output nodes, 1 per motor

OBJ
  utilities     : "utilities"

VAR
  long fHidden[HiddenNodes]                                                     ' hidden values
  long fOutput[OutputNodes]                                                     ' output values

DAT
' training data from Spin2_weight_trainer
' run the training data using the Spin2_weight_trainer. Copy and paste the results here
'
' The first are weights for the hidden nodes:  (InputNodes+1)  * HiddenNodes
' The second are weights for the output nodes: (HiddenNodes+1) * OutputNodes
'
{
' from spin2 trainer: nn_train.spin2
fHiddenWeights
 long 7.072293e-01
 long 1.146613e-01
 long 2.863246e+00
 long -2.487716e-02
 long -6.357699e-01
 long 3.908694e-01
 long -1.908637e-01
 long 9.856998e-02
 long -5.147691e-02
 long 3.703414e+00
 long 3.763179e-01
 long 2.729059e+00
 long -1.485012e+00
 long -2.462658e+00
 long -6.096124e-01
 long -8.521959e+00
 long 1.312684e+00
 long 1.453432e-01
 long 2.788676e-02
 long 5.950765e-02
 long -3.249168e-01
 long 2.976849e+00
 long -3.033682e-01
 long 2.549369e+00
 long 1.246289e+00
 long 2.162237e-01
 long 2.378869e+00
 long -5.248801e-01
 long -5.029560e-01
 long 8.127416e-01
 long 2.893655e-01
 long -1.134241e+00
 long -3.198640e+00
 long 1.050889e+00
 long -2.811598e-01
 long -4.828155e+00
 fEndHiddenWeights
 fOutputWeights
 long -2.308291e+00
 long -1.637372e+00
 long -2.867199e-01
 long 1.076637e+00
 long -4.864613e+00
 long -1.090867e+00
 long 5.831216e+00
 long 4.292695e+00
 long 1.442060e+00
 long 2.020371e+00
 long -1.597189e+00
 long -5.768107e+00
 long 3.180980e-02
 long -2.769673e-01
 fEndOutputWeights
'}

' from PC trainer
fHiddenWeights
long -0.771484375
long  1.359375
long  0.45068359375
long  -1.74609375
long  -0.356201171875
long  -1.220703125

long  0.169189453125
long  -0.26416015625
long  -1.35546875
long  -1.21484375
long  0.54443359375
long  -0.65869140625

long  1.189453125
long  -1.05078125
long  -0.397216796875
long  7.68359375
long  -0.4580078125
long  0.9111328125

long  1.0556640625
long  -0.1793212890625
long  -1.04296875
long  -1.57421875
long  0.99951171875
long  -0.0469970703125

long  -4.0
long  1.81640625
long  0.755859375
long  -1.22265625
long  -0.415771484375
long  -0.68701171875

long  1.3857421875
long  -1.1259765625
long  2.0
long  -1.197265625
long  -0.0611572265625
long  1.220703125
fEndHiddenWeights

fOutputWeights
long 4.00390625
long  2.462890625

long  -3.546875
long  -2.0

long  -1.044921875
long  2.638671875

long  -5.7890625
long  -4.63671875

long  0.6484375
long  -2.0

long  2.06640625
long  2.962890625

long  1.482421875
long  -0.8515625
fEndOutputWeights
'}

pub null()

pub start() : result
' 0 is ok
  ' size of weight table must match expected based on node sizes
  if (@fEndHiddenWeights-@fHiddenWeights)/4 <> (InputNodes+1)*HiddenNodes
    debug(" Hidden weight size mis-match ", udec((fEndHiddenWeights-fHiddenWeights)/4), " ", udec((InputNodes+1)*HiddenNodes))
    return 1
  if (@fEndOutputWeights-@fOutputWeights)/4 <> (HiddenNodes + 1)*OutputNodes
    debug(" Output weight size mis-match ", udec((fEndOutputWeights-fOutputWeights)/4), " ", udec((HiddenNodes + 1)*OutputNodes))
    return 2
  return 0

pub drive_nn(pInput, pOutput) | index, pout
' translate between demo_dual_motor_rc input/output
'   input: 0.0-1.0, lidar detection range (L, FL, F, FR, R)
'   output: -100 to 100, left/right motor speed
' 247-341us with log_w_approx_exp_no_overflow16_clamped sigmoid
  pout := InputToOutput(pInput)                                                 ' input to NN to obtain output

  repeat index from 0 to OutputNodes-1
    long[pOutput][index] := round(long[pout][index] *. 200.0) - 100             ' convert 0 -> +1 to -100 to 100

pri InputToOutput(pfTestInput) : poutput | tempindex, tempindex1, outer, inner, faccum, t1
' core of the neutral network
' input nodes are  5: 0.0-1.0 assumption is true if something left/front-left, front, front-right, right
' output nodes are 2: 0.0-1.0 left/right motor 0 is full speed backwards, 0.5 is stopped, 1.0 is full speed forwards
' hidden nodes are 6
'
' cordic operations (1 multiply)*(inputnodes + outputnodes)*hiddennodes
'                   (hiddennodes+outputnode) * sigmoid(4 multiply, 2 divide)
' total approx = (42+32) 74 multiply, 16 divide, ~60us, so 19% of excution time
'
  ' Compute hidden layer activations
  ' float HiddenWeights[InputNodes + 1][HiddenNodes]                            ' weight per input node per hidden node
  tempindex := InputNodes*HiddenNodes                                           ' bias is handled as an extra input node
  repeat outer from 0 to HiddenNodes-1
    faccum := long[@fHiddenWeights][tempindex++]                                ' bias to start adding up weights
    tempindex1 := outer
    repeat inner from 0 to InputNodes-1
      if (t1 := long[pfTestInput][inner]) <> 0                                  ' skip the 0 (note only checking for bits 0)
        faccum := faccum +. (t1 *. long[@fHiddenWeights][tempindex1])           ' sum of weights per hidden node per input node
      tempindex1 += HiddenNodes                                                 ' next hidden node
    fHidden[outer] := utilities.sigmoid(faccum)                                 ' total per hidden node, curve flattened using logistic function

  ' Compute output layer activations
  ' float OutputWeights[HiddenNodes + 1][OutputNodes];                          ' weight per hidden node per output node
  tempindex := HiddenNodes*OutputNodes                                          ' bias is handled as an extra hidden node
  repeat outer from 0 to OutputNodes-1
    faccum := long[@fOutputWeights][tempindex++]                                ' bias
    tempindex1 := outer
    repeat inner from 0 to HiddenNodes-1
      faccum := fAccum +. (fHidden[inner] *. long[@fOutputWeights][tempindex1]) ' sum of weights per output node per hidden node
      tempindex1 += OutputNodes
    fOutput[outer] := utilities.sigmoid(faccum)                                 ' total per output node, curve flattened using logistic function

  return @fOutput
'
VAR
  byte disp[6]

DAT
lidardisp   byte "L#F#R", 0

PUB updatedisplaylidar(pfin) : result | i
' convert lidar detection into displayable string
  strcopy(@disp, @lidardisp, 5)
  repeat i from 0 to 4
    if long[pfin][i] <. 0.5
      disp[i] := " "
  return @disp

' set of tests that run the Lidar simultated inputs through the neutral network and prints the results
'
DAT
ftestinputs
        long 0.0,  0.0,  0.0,  0.0,  0.0        ' test1
        long 1.0,  1.0,  1.0,  1.0,  1.0        ' test2
        long 0.0,  0.0,  1.0,  0.0,  0.0        ' test3
        long 0.0,  1.0,  1.0,  1.0,  0.0        ' test4
        long 1.0,  0.0,  1.0,  0.0,  1.0        ' test5
        long 1.0,  1.0,  1.0,  0.0,  0.0        ' test6
        long 0.0,  0.0,  1.0,  1.0,  1.0        ' test7
        long 1.0,  1.0,  1.0,  1.0,  0.0        ' test8
        long 0.5,  0.5,  0.5,  0.5,  0.5        ' test9
        long 0.0,  0.0,  0.5,  0.0,  0.0        ' test10
        long 0.25, 0.25, 0.5,  0.25, 0.25       ' test11
        long 0.0,  0.4,  0.5,  0.4,  0.0        ' test12
endftestinputs

pub test_nn() | pftest, nout[2], i, t, clk
' run set of tests on nn
'
  clk := clkfreq/1_000_000
  repeat i from 0 to ((@endftestinputs - @ftestinputs)/(4*5))-1
    pftest := @long[@ftestinputs][5*i]
    t := getct()
    drive_nn(pftest, @nout)
    t := getct() - t
    debug("test", udec_(i+1), " ", udec_(t/clk), "us lidar=(", zstr_(updatedisplaylidar(pftest)), ") motors= ", sdec_long_array_(@nout, 2))
'
CON { license }
{{

 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright (c) 2023 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================
}}